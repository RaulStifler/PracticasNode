function isObject(obj) {
  const type = typeof obj;
  return !!obj && (type === 'object' || type === 'function');
}

function isFunction(obj) {
  return typeof obj === 'function';
}

var extractFunctions = function (...args) {
  let result = [];
  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (isFunction(arg)) result.push(arg);else if (Array.isArray(arg)) result = result.concat(arg.filter(isFunction));
  }
  return result.length === 0 ? undefined : result;
}

function isPlainObject(value) {
  return !!value && typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype;
}

/**
 * The 'src' argument plays the command role.
 * The returned values is always of the same type as the 'src'.
 * @param dst
 * @param src
 * @returns {*}
 */
function mergeOne(dst, src) {
  if (src === undefined) return dst;

  // According to specification arrays must be concatenated.
  // Also, the '.concat' creates a new array instance. Overrides the 'dst'.
  if (Array.isArray(src)) return (Array.isArray(dst) ? dst : []).concat(src);

  // Now deal with non plain 'src' object. 'src' overrides 'dst'
  // Note that functions are also assigned! We do not deep merge functions.
  if (!isPlainObject(src)) return src;

  // See if 'dst' is allowed to be mutated. If not - it's overridden with a new plain object.
  const returnValue = isObject(dst) ? dst : {};

  const keys = Object.keys(src);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];

    const srcValue = src[key];
    // Do not merge properties with the 'undefined' value.
    if (srcValue !== undefined) {
      const dstValue = returnValue[key];
      // Recursive calls to mergeOne() must allow only plain objects or arrays in dst
      const newDst = isPlainObject(dstValue) || Array.isArray(srcValue) ? dstValue : {};

      // deep merge each property. Recursion!
      returnValue[key] = mergeOne(newDst, srcValue);
    }
  }

  return returnValue;
}

var merge = function (dst, ...srcs) {
  return srcs.reduce(mergeOne, dst);
}

const assign$1 = Object.assign;

var standardiseDescriptor = function ({
  methods,

  properties,
  props,
  refs,

  initializers,
  init,

  deepProperties,
  deepProps,

  propertyDescriptors,

  staticProperties,
  statics,

  staticDeepProperties,
  deepStatics,

  staticPropertyDescriptors,

  configuration,
  conf,

  deepConfiguration,
  deepConf
} = {}) {
  const p = isObject(props) || isObject(refs) || isObject(properties) ? assign$1({}, props, refs, properties) : undefined;

  let dp = isObject(deepProps) ? merge({}, deepProps) : undefined;
  dp = isObject(deepProperties) ? merge(dp, deepProperties) : dp;

  const sp = isObject(statics) || isObject(staticProperties) ? assign$1({}, statics, staticProperties) : undefined;

  let dsp = isObject(deepStatics) ? merge({}, deepStatics) : undefined;
  dsp = isObject(staticDeepProperties) ? merge(dsp, staticDeepProperties) : dsp;

  const c = isObject(conf) || isObject(configuration) ? assign$1({}, conf, configuration) : undefined;

  let dc = isObject(deepConf) ? merge({}, deepConf) : undefined;
  dc = isObject(deepConfiguration) ? merge(dc, deepConfiguration) : dc;

  return {
    methods,
    properties: p,
    initializers: extractFunctions(init, initializers),
    deepProperties: dp,
    staticProperties: sp,
    staticDeepProperties: dsp,
    propertyDescriptors,
    staticPropertyDescriptors,
    configuration: c,
    deepConfiguration: dc
  };
}

const assign$2 = Object.assign;

/**
 * Creates new factory instance.
 * @param {object} descriptor The information about the object the factory will be creating.
 * @returns {Function} The new factory function.
 */
function createFactory(descriptor) {
  return function Stamp(options, ...args) {
    const obj = Object.create(descriptor.methods || {});

    merge(obj, descriptor.deepProperties);
    assign$2(obj, descriptor.properties);
    Object.defineProperties(obj, descriptor.propertyDescriptors || {});

    if (!descriptor.initializers || descriptor.initializers.length === 0) return obj;

    if (options === undefined) options = {};
    return descriptor.initializers.filter(isFunction).reduce((resultingObj, initializer) => {
      const returnedValue = initializer.call(resultingObj, options, { instance: resultingObj, stamp: Stamp, args: [options].concat(args) });
      return returnedValue === undefined ? resultingObj : returnedValue;
    }, obj);
  };
}

/**
 * Returns a new stamp given a descriptor and a compose function implementation.
 * @param {object} [descriptor={}] The information about the object the stamp will be creating.
 * @param {Function} composeFunction The "compose" function implementation.
 * @returns {Function}
 */
function createStamp(descriptor, composeFunction) {
  const Stamp = createFactory(descriptor);

  merge(Stamp, descriptor.staticDeepProperties);
  assign$2(Stamp, descriptor.staticProperties);
  Object.defineProperties(Stamp, descriptor.staticPropertyDescriptors || {});

  const composeImplementation = isFunction(Stamp.compose) ? Stamp.compose : composeFunction;
  Stamp.compose = function _compose(...args) {
    return composeImplementation.apply(this, args);
  };
  assign$2(Stamp.compose, descriptor);

  return Stamp;
}

/**
 * Mutates the dstDescriptor by merging the srcComposable data into it.
 * @param {object} dstDescriptor The descriptor object to merge into.
 * @param {object} [srcComposable] The composable (either descriptor or stamp) to merge data form.
 * @returns {object} Returns the dstDescriptor argument.
 */
function mergeComposable(dstDescriptor, srcComposable) {
  const srcDescriptor = srcComposable && srcComposable.compose || srcComposable;
  if (!isObject(srcDescriptor)) return dstDescriptor;

  const combineProperty = (propName, action) => {
    if (!isObject(srcDescriptor[propName])) return;
    if (!isObject(dstDescriptor[propName])) dstDescriptor[propName] = {};
    action(dstDescriptor[propName], srcDescriptor[propName]);
  };

  combineProperty('methods', assign$2);
  combineProperty('properties', assign$2);
  combineProperty('deepProperties', merge);
  combineProperty('propertyDescriptors', assign$2);
  combineProperty('staticProperties', assign$2);
  combineProperty('staticDeepProperties', merge);
  combineProperty('staticPropertyDescriptors', assign$2);
  combineProperty('configuration', assign$2);
  combineProperty('deepConfiguration', merge);
  if (Array.isArray(srcDescriptor.initializers)) {
    dstDescriptor.initializers = srcDescriptor.initializers.reduce((result, init) => {
      if (isFunction(init) && result.indexOf(init) < 0) {
        result.push(init);
      }
      return result;
    }, Array.isArray(dstDescriptor.initializers) ? dstDescriptor.initializers : []);
  }

  return dstDescriptor;
}

/**
 * Given the list of composables (stamp descriptors and stamps) returns
 * a new stamp (composable factory function).
 * @param {...(object|Function)} [composables] The list of composables.
 * @returns {Stamp} A new stamp (aka composable factory function)
 */
function compose(...composables) {
  const descriptor = [this].concat(composables).filter(isObject).reduce(mergeComposable, {});
  return createStamp(descriptor, compose);
}

/**
 * The Stamp Descriptor
 * @typedef {Function|Object} Descriptor
 * @returns {Stamp} A new stamp based on this Stamp
 * @property {Object} [methods] Methods or other data used as object instances' prototype
 * @property {Array<Function>} [initializers] List of initializers called for each object instance
 * @property {Object} [properties] Shallow assigned properties of object instances
 * @property {Object} [deepProperties] Deeply merged properties of object instances
 * @property {Object} [staticProperties] Shallow assigned properties of Stamps
 * @property {Object} [staticDeepProperties] Deeply merged properties of Stamps
 * @property {Object} [configuration] Shallow assigned properties of Stamp arbitrary metadata
 * @property {Object} [deepConfiguration] Deeply merged properties of Stamp arbitrary metadata
 * @property {Object} [propertyDescriptors] ES5 Property Descriptors applied to object instances
 * @property {Object} [staticPropertyDescriptors] ES5 Property Descriptors applied to Stamps
 */

/**
 * The Stamp factory function
 * @typedef {Function} Stamp
 * @returns {*} Instantiated object
 * @property {Descriptor} compose - The Stamp descriptor and composition function
 */

function isStamp(obj) {
  return isFunction(obj) && isFunction(obj.compose);
}

const assign = Object.assign;

function createUtilityFunction(propName, action) {
  return function composeUtil() {
    const descriptor = {};
    descriptor[propName] = action({}, ...arguments);
    return (this && this.compose || stampit).call(this, descriptor);
  };
}

const methods = createUtilityFunction('methods', assign);

const properties = createUtilityFunction('properties', assign);
function initializers(...args) {
  return (this && this.compose || stampit).call(this, {
    initializers: extractFunctions(...args)
  });
}
const deepProperties = createUtilityFunction('deepProperties', merge);
const staticProperties = createUtilityFunction('staticProperties', assign);
const staticDeepProperties = createUtilityFunction('staticDeepProperties', merge);
const configuration = createUtilityFunction('configuration', assign);
const deepConfiguration = createUtilityFunction('deepConfiguration', merge);
const propertyDescriptors = createUtilityFunction('propertyDescriptors', assign);

const staticPropertyDescriptors = createUtilityFunction('staticPropertyDescriptors', assign);

const allUtilities = {
  methods,

  properties,
  refs: properties,
  props: properties,

  initializers,
  init: initializers,

  deepProperties,
  deepProps: deepProperties,

  staticProperties,
  statics: staticProperties,

  staticDeepProperties,
  deepStatics: staticDeepProperties,

  configuration,
  conf: configuration,

  deepConfiguration,
  deepConf: deepConfiguration,

  propertyDescriptors,

  staticPropertyDescriptors
};

/**
 * Infected stamp. Used as a storage of the infection metadata
 * @type {Function}
 * @return {Stamp}
 */
const baseStampit = compose({ staticProperties: allUtilities }, {
  staticProperties: {
    create(...args) {
      return this(...args);
    },
    compose: stampit // infecting
  }
});

/**
 * Infected compose
 * @return {Stamp}
 */
function stampit(...args) {
  args = args.filter(isObject).map(arg => isStamp(arg) ? arg : standardiseDescriptor(arg));

  // Calling the standard pure compose function here.
  return compose.apply(this || baseStampit, args);
}

const exportedCompose = stampit.bind(); // bind to 'undefined'
stampit.compose = exportedCompose;

// Setting up the shortcut functions
var stampit$1 = assign(stampit, allUtilities);

export { methods, properties, properties as refs, properties as props, initializers, initializers as init, deepProperties, deepProperties as deepProps, staticProperties, staticProperties as statics, staticDeepProperties, staticDeepProperties as deepStatics, configuration, configuration as conf, deepConfiguration, deepConfiguration as deepConf, propertyDescriptors, staticPropertyDescriptors, exportedCompose as compose };export default stampit$1;
//# sourceMappingURL=stampit.mjs.map
